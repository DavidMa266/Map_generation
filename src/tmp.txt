#include "map.hpp"
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <fstream>

int q_direction(int q, int dir) {return q + q_directions[dir%6];}
int r_direction(int r, int dir) {return r + r_directions[dir%6];}


double fade(double t) {return t * t * t * (t * (t * 6 - 15) + 10);}
double lerp(double a, double b, double x) {return a + x * (b - a);}

//Produces a random array, sized 512 of elements 0-255
vector<int> random_arr(int num)
{
    srand ( time(NULL) );
	vector<int> p(num);
	vector<int> tmp(num);
	vector<int> res(num * 2);

	for(int i = 0; i < num; i ++) {tmp[i] = i;}
	for(int i = 0; i < num; i++)
	{
		int r_num = rand() % (num-i);
		p[i] = tmp[r_num];

		tmp.erase(tmp.begin() + r_num);
	}

    for(int i = 0; i < num*2; i++) {res[i] = p[i % num];}
	return res;
}

//Improved Perlin Noise function
//Supposedly somehow using (1, 1), (1, -1), (-1, 1), (-1, -1) is better looking and computationaly faster (true) 
//Than just forming random gradient vectors
//Basically automatically computes both dot product using the gradient and distance function.
double gradient(int hash, double x, double y)
{
    switch(hash & 0x)
    {
        case 0x0: return  x + y;
        case 0x1: return -x + y;
        case 0x2: return  x - y;
        case 0x3: return -x - y;
        case 0x4: return x;
        case 0x5: return -x;
        case 0x6: return y;
        case 0x7: return -y;
        default: return 0; // never happens
    }
}

double perlin(int x, int y, int perlin_target, vector<int> p)
{
	//So for each point, we find xi, yi the bottom left corner square. 
	//Perlin target is the number of these squares we have, which should be 32
	//I should get the exact same xi and yi values after every 32 squares.
	int xi = x % perlin_target;
	int yi = y % perlin_target;

	//We find in terms of percentage the value within the square.
	double xf = double(xi) / double(perlin_target);
	double yf = double(yi) / double(perlin_target);

	double u = fade(xf);
	double v = fade(yf);


	//Gradients associated witht he four corners
	int x1y1, x1y2, x2y1, x2y2;
	x1y1 = p[p[xi] + yi];
	x1y2 = p[p[xi] + yi + 1];
	x2y1 = p[p[xi + 1] + yi];
	x2y2 = p[p[xi + 1] + yi + 1];


	double d_x1y1, d_x1y2, d_x2y1, d_x2y2;
	d_x1y1 = gradient(x1y1, xf, yf);
	d_x1y2 = gradient(x1y2, xf, yf - 1);
	d_x2y1 = gradient(x2y1, xf - 1, yf);
	d_x2y2 = gradient(x2y2, xf - 1, yf - 1);

	double a, b;

	a = lerp(d_x1y1, d_x1y2, u);
	b = lerp(d_x2y1, d_x2y2, u);
	return (lerp(a, b, v) + 1 )/ 2;
}



vector<vector<double> > perlin_noise(int square_len, int num_square)
{
	//So we form a 256 x 256 array
	int size = square_len * num_square;
	vector<vector<double> > gradient_map(size);
	for(int i = 0; i < size; i++)
	{
		vector<double> tmp(size);
		gradient_map[i] = tmp;
	}


	//And we create a random array P, sized 512e that will determine which gradients we use.
	vector<int> p = random_arr(size);
	
	for(int i = 0; i < size; i++)
	{
		for(int j = 0; j < size; j++)
		{
			gradient_map[i][j] = perlin(i, j, size, p);
		}
	}
	return gradient_map;


}




vector<vector<int> > map_generator(int width, int height, int num_seeds)
{



}


Hex get_hex(Hex origin, int dir)
{
	return Hex(0,0);
}



int main(){
	int square_dim = 8;
	int num_square = 32;
	ofstream myfile;
	myfile.open ("data0.csv");
	vector<vector<double> > x = perlin_noise(square_dim, num_square);

	for(int i = 0; i < square_dim*num_square; i++)
	{
		for(int j = 0; j < square_dim* num_square; j++)
		{
			myfile << i << "," << j << "," << x[i][j] << endl;
		}
	}
	myfile.close();
}